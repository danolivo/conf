% Use xelatex to generate pdf file of this presentation

\documentclass[xcolor=table]{beamer}
\usepackage{roboto}
\usepackage[russian]{babel}
\usetheme{Copenhagen}

% Simple way to put a code listing to the slide
\usepackage{listings}

% Tabular-specific packages
\usepackage{makecell}
\usepackage{tabu, booktabs}

\usepackage[symbol*]{footmisc}
\setfnsymbol{wiley}

\usepackage{tikz}
\usepackage{graphicx}
  \logo{\includegraphics[scale=0.1]{pics/PostgresPro_logo}}
%Information to be included in the title page:
\title{pg\_index\_stats}
\subtitle{manage\ extended\ statistics\ automatically}
\author{\underline{Lepikhov A.}, Rybakina A.}
\institute{Postgres Professional}
%\titlegraphic{\includegraphics[scale=0.05]{project_url}}
\date{2024}

% Add page numbers in footnote
\expandafter\def\expandafter\insertshorttitle\expandafter{%
  \insertshorttitle\hfill%
  \insertframenumber\,/\,\inserttotalframenumber}

% Custom commands
\newcommand{\tbltext}[1]{\ttfamily\footnotesize#1}

% Custom colours: https://latexcolor.com
\definecolor{armygreen}{rgb}{0.29, 0.33, 0.13}
\definecolor{darkgreen}{rgb}{0.0, 0.5, 0.0}
\definecolor{lightlightgray}{gray}{0.9}

% Default listing format
\lstset{language=sql, frame=none, tabsize=2, identifierstyle=\color{black},
  showspaces=false, showtabs=false, showstringspaces=false,
  columns=fullflexible, % Restore default spaces between letters
  basicstyle=\rmfamily\scriptsize,
  stringstyle=\color{purple},
  keywordstyle=\bfseries\color{green!40!black},
  numberstyle=\tiny\color{gray}}

% -----------------------------

\begin{document}

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Title
%
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}
\titlepage
   \tikz [remember picture,overlay]
    \node at
        ([yshift=2.0cm, xshift=-4.8cm]current page.center) 
        {\includegraphics[scale=0.05]{pics/project_logo}};

\end{frame}

% My name is Andrei. Today, I want to spend this time talking about extending statistics. It attempts to find correlations between columns in the table and more accurately predict cardinality. Or, in other words, the size of the data returned by the table scan operator. It was introduced in the PG12, but since then, it has been used quite rarely because of some questions, like over which set of columns we should create these statistics. Or how to control the overhead of these statistics calculations. Because it is a costly procedure, of course.
% With a flow of performance reports related to the accuracy of optimizer predictions, we designed an extension that manages extended statistics creation/modification/removal. For the rationale of statistics management, we have chosen indexes. I'm going to explain how it works, the reasons for it, and the results.


% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% About me
%
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Self Introduction}
\begin{columns}\begin{column}{0.6\textwidth}
\begin{itemize}
  \item Core Developer in Postgres Professional since 2017.
  \item Contributing to the PostgreSQL project since 2017:\\ \textit{Self-Join Elimination, GROUP-BY optimisation, OR <-> ANY transformation}.
  \item Ph.D. in Computer Sciences (Distributed Databases), MSU, 2008.
  \item Designed extensions: AQO, sr\_plan, pg\_index\_stats ...
\end{itemize}
\end{column}
\begin{column}{0.4\textwidth}
  \includegraphics[scale=0.05]{pics/selfie}
\end{column}\end{columns}
\end{frame}

% Because I am giving a speech for the first time in Asia, Let me tell you about myself shortly.
%I live in Thailand. I have been contributing to PostgreSQL since 2017. I am a core developer at Postgres Professional company. Most of my reviews and commits are dedicated to optimization issues. This year, two of my features were committed: Self-Join Removal and group-by optimization.
%I'm a Ph.D. Candidate in distributed databases, awarded in 2009. My most popular projects, which you would know, are Multimaster, Shardman, Adaptive Query Optimizer, and Plan Freezing. Previously, I attempted to resolve optimization issues with a query-driven approach. Nowadays, having understood the limitations of the query-driven approach in PG, I'm attempting to resolve the planning issues with a data-driven approach, elaborating on statistics.

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Extended Statistics short introduction
%
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Extended Statistics}
\vskip0pt plus 1filll
CREATE STATISTICS ON x1,x2,x3,x4 FROM tablename;
\vspace{10pt}
\begin{itemize}
  \item \textbf{ndistinct} - number of distinct values on all combinations of columns: (x1,x2),(x1,x3),(x1,x2,x3)...
  \item \textbf{MCV} - \textbf{M}ost \textbf{C}ommon \textbf{V}alues on composite value  of (x1,x2,x3).
  \item \textbf{dependencies} - functional dependencies between combinations of columns: x1->x2, (x1,x2)->x3,...
\end{itemize}
\vskip0pt plus 1filll
\begin{columns}\begin{column}{0.03\textwidth}
\includegraphics[scale=0.1]{pics/vondra_extstat}
\end{column}\begin{column}{0.8\textwidth}
\textit{Vondra. T. CREATE STATISTICS improvements,\\ PGConf.DE 2022}
\end{column}\end{columns}
\end{frame}
%I want to mention the extended statistic to ensure we are on the same page. The best description of that feature can be found in Tomas Vondra's presentation. He is the leading developer of this feature. You can find it by following the link in the QR code.
%This type of statistic is designed to provide information about the joint distribution of a set of columns or expressions. The slide provides an example of its definition.
%These statistics are still not extensible and include three types of data: number of distinct values, most common values and dependency factor.
%The number of distinct values is calculated for any possible combinations of the defining columns. The MCV is a collection of the most frequent values, and dependency shows us the factor of dependency between any possible combination of columns in the set of columns. 

\begin{frame}[fragile]\frametitle{Laboriousness of Extended Statistics}
\begin{itemize}
  \item \textbf{ndistinct} - 1 integer for each of $2^n - (n+1)$ combinations
  \item \textbf{MCV} - two arrays: values[] and frequences[].
  \item \textbf{dependencies} - 1 float value for each of combinations
\end{itemize}
\vspace{20pt}
\begin{center}
\begin{tabular}{|l|c|c|c|c|c|}
\hline
columns: & 2 & 3 & 4 & ... & 8 \\
\hline
distinct combinations: & 1 & 4 & 11 & ... & 247 \\
\hline
dependency combinations: & 2 & 9 & 28 & ... & 1016 \\
\hline
\end{tabular}
\end{center}
\end{frame}

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% What the extension do
%
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Quick start}
\begin{lstlisting}[basicstyle=\footnotesize]
CREATE EXTENSION 'pg_index_stats';
CREATE TABLE test (x int,y int,z text);
CREATE INDEX ON test (x,y);
CREATE INDEX ON test (z,y);
\dX
\end{lstlisting}
\begin{lstlisting}[basicstyle=\tiny]
                         List of extended statistics
 Schema |     Name      |   Definition   | Ndistinct | Dependencies |   MCV   
--------+---------------+----------------+-----------+--------------+---------
 public | test_x_y_stat | x, y FROM test | defined   | defined      | defined
 public | test_z_y_stat | y, z FROM test | defined   | defined      | defined
\end{lstlisting}
\end{frame}
% И вот как первый шаг на пути развития data-driven approach in PostgreSQL I have designed this simple extension. What it does. You can find that out by using a simple example shown on the slide. Just by creating this extension (it can be loaded dynamically), you add one more action on any operation with indexes. For example, here, we create a plain table and a couple of indexes.
% Immediately after that, if you look into the extended statistics created, you can find two new statistics (if their definitions don't duplicate any other statistics created before).
% These statistics dependent on the extension and index relation. So

\begin{frame}[fragile]\frametitle{Quick start - II}
\begin{lstlisting}[basicstyle=\footnotesize]
DROP INDEX test_x_y_idx;
\end{lstlisting}
\begin{lstlisting}[basicstyle=\tiny]
                         List of extended statistics
 Schema |     Name      |   Definition   | Ndistinct | Dependencies |   MCV   
--------+---------------+----------------+-----------+--------------+---------
 public | test_z_y_stat | y, z FROM test | defined   | defined      | defined
\end{lstlisting}
\begin{lstlisting}[basicstyle=\footnotesize]
SELECT stxname,obj_description(oid, 'pg_statistic_ext')
FROM (SELECT oid,stxname FROM pg_statistic_ext);
\end{lstlisting}
\begin{lstlisting}[basicstyle=\tiny]
    stxname    |             obj_description              
---------------+------------------------------------------
 test_z_y_stat | pg_index_stats - multivariate statistics
\end{lstlisting}
\end{frame}
% If you delete one of the indexes after committing this operation, you will find only one statistic survived. Deleting the extension removes all auto-generated statistics if you don't change their dependencies in the system catalogue manually.
% Also, auto-generated statistics have some specific sign - it is a comment assigned for each such object: you can just use the description function to identify such statistics for some reasons - for example, to script actions.

\begin{frame}[fragile]\frametitle{GUCs \& Funcs}
\begin{itemize}
  \item \textit{mode} - disabled | all | univariate | multivariate
  \item \textit{columns\_limit}
  \item \textit{pg\_index\_stats\_build(relname, mode)}
  \item \textit{pg\_index\_stats\_rebuild()}
  \item \textit{pg\_index\_stats\_remove()}
\end{itemize}
\end{frame}
% Also, the extension provides a few parameters related to the limitations and scope of the extension. We invented them because we quickly found that in real life, it could be harmful if someone creates an index containing 5-10 columns. And some people do that. No idea why.
% Moreover, you have functions to manually delete all such stats or rebuild them over all tables in the database or just over one heap table. 

\begin{frame}[fragile]\frametitle{Short Tech Dive}
Two-step process:
\begin{itemize}
  \item Object Access Hook - gather candidate OIDs 
  \item Utility Hook - create extended statistics after a successful utility statement
\end{itemize}
Set dependency of auto-generated statistics on the extension and index relation.\\
Add specific description for auto-generated statistics
\end{frame}
% A bit of tech details that can be useful for DBA and developers. We realised that it is not trivial to create a database object while creating another index object. Here, I talk about index and extension statistics built upon its definition. So, the procedure is divided into two steps:
% - Object creation. Here, we identify the creation of a table. You can't differentiate between plain tables, foreign tables, indexes, etc.
% - Second step - is an end of utility operation. Here, we can already see the object created right before, its type and name, and we can build extended statistics if this object is an appropriate index.
% And that's almost all about the extension. It's something like a TikTok-style speech. In the rest of the talk, I would like to explain why we have done it and how it works.

\begin{frame}[fragile]\frametitle{Query auto-generation frameworks}
\begin{center}
	\includegraphics[scale=0.4]{pics/orms}
\end{center}
\end{frame}

\begin{frame}[fragile]\frametitle{What is the reason?}
	\includegraphics[scale=0.52]{pics/querytree}
\end{frame}

\begin{frame}[fragile]\frametitle{Redundant expressions}
\lstset{language=sql, frame=none, tabsize=2, identifierstyle=\color{black},
  backgroundcolor=\color{white},
  keywordstyle=\bfseries\color{green!40!black},showspaces=false, showtabs=false, showstringspaces=false}
\begin{center}
\begin{tabular}{|l|c|c|}
	\hline
	% Header
	\multicolumn{1}{|c|}{Query} & Planned rows & Actual rows \\
	\hline
\begin{lstlisting}[basicstyle=\footnotesize]
SELECT * FROM power_plants
WHERE
  country = 'RUS';
\end{lstlisting}
& \cellcolor{green}544 & \cellcolor{green}544 \\
	\hline
\begin{lstlisting}[basicstyle=\footnotesize]
SELECT * FROM power_plants
WHERE
  country = 'RUS' AND
  country_long = 'Russia';
\end{lstlisting}
& \cellcolor{red}8 & \cellcolor{green}544 \\
	\hline
\end{tabular}
\footnotetext{
\includegraphics[scale=0.4]{pics/GPPD-copyright}
}
\end{center}
\end{frame}

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% The main question that should be explained.
%
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{The question}
\begin{quote}
Why can database systems, which manage all the data, not analyse it and find at least in-table dependencies and interconnections?
\end{quote}
\end{frame}

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Rationale for the usage of indexes. An example.
%
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Why indexes?}
\begin{lstlisting}[basicstyle=\footnotesize]
Table "Parcels":
Indexes:
    "parcel_pkey" PRIMARY KEY, btree (id)
    "parcel_parcel_id" btree (parcel_id)
    "parcel_id_prik" btree (parcel_id, prik)
    "parcel_id_sn_pol" btree (parcel_id, sn_pol)
    "parcel_par_begin" btree (parcel_id, prik_begin_period)
    "parcel_par_patient" btree (parcel_id, patient_id)
    "parcel_par_recid" btree (parcel_id, recid)
    "parcel_per_prik" btree (period, prik)
\end{lstlisting}
\end{frame}
  
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% How extended statistics helps
%
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Extended v/s Plain Statistics}
SELECT * FROM power\_plants WHERE ...
\begin{center}
\begin{tabular}{|l|c|c|c|}
	\hline
	% Header
	\multicolumn{1}{|c|}{\tbltext{Query}} & \tbltext{\makecell{Plain\\ stat}} & \tbltext{\makecell{Extended\\ stat}} & \tbltext{\makecell{Actual\\ rows}} \\
	\hline
\begin{lstlisting}
country = 'RUS';
\end{lstlisting}
& \cellcolor{green}544 & \cellcolor{green}545 & \cellcolor{green}544 \\
	\hline
\begin{lstlisting}
AND primary_fuel IN ('Solar')
\end{lstlisting}
& \cellcolor{darkgreen}166 & \cellcolor{green}57 & \cellcolor{green}57 \\
	\hline
\begin{lstlisting}
primary_fuel IN
  ('Solar', 'Biomass')
\end{lstlisting}
& \cellcolor{darkgreen}189 & \cellcolor{green}60 & \cellcolor{green}60 \\
	\hline
\begin{lstlisting}
primary_fuel IN
  ('Solar', 'Biomass', 'Coal')
\end{lstlisting}
& \cellcolor{darkgreen}225 & \cellcolor{green}156 & \cellcolor{green}156 \\
	\hline
\begin{lstlisting}
AND source = 'Wiki-Solar'
\end{lstlisting}
& \cellcolor{red}24 & \cellcolor{green}46 & \cellcolor{green}40 \\
	\hline
\begin{lstlisting}
AND longitude > 40.
AND longitude < 70.
\end{lstlisting}
& \cellcolor{red}1 & \cellcolor{red}1 & \cellcolor{green}33 \\
	\hline
\end{tabular}
\footnotetext{
\includegraphics[scale=0.4]{pics/GPPD-copyright}
}
\end{center}
\end{frame}

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Why do we need a multicolumn histogram
%
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Does multicolumn histogram make sense?}
In general - no. We need a multidimensional histogram. But it can make sense if we follow the definition of indexes ...
\vspace{10pt}
\begin{lstlisting}
SELECT * FROM power_plants
WHERE
  country = 'RUS' AND
  primary_fuel IN ('Solar', 'Biomass', 'Coal') AND
  AND source = 'Wiki-Solar' AND
  longitude > 40. AND longitude < 70.;
\end{lstlisting}
\begin{center}
	\includegraphics[scale=0.4]{pics/histogram}
\end{center}
\end{frame}

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Extended statistics v/s histogram
%
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Multicolumn histogram advantage}
SELECT * FROM power\_plants WHERE ...
\begin{center}
\begin{tabular}{|l|c|c|c|c|}
	\hline
	% Header
	\multicolumn{1}{|c|}{\tbltext{Query}} & \tbltext{\makecell{Plain\\ stat}} & \tbltext{\makecell{Extended\\ stat}} & \tbltext{Histogram} & \tbltext{\makecell{Actual\\ rows}} \\
	\hline
\begin{lstlisting}
country = 'RUS';
\end{lstlisting}
& \cellcolor{green}544 & \cellcolor{green}545 & \cellcolor{green}544 & \cellcolor{green}544 \\
	\hline
\begin{lstlisting}
AND primary_fuel IN ('Solar')
\end{lstlisting}
& \cellcolor{darkgreen}166 & \cellcolor{green}57 & \cellcolor{green}57 & \cellcolor{green}57 \\
	\hline
\begin{lstlisting}
primary_fuel IN
  ('Solar', 'Biomass')
\end{lstlisting}
& \cellcolor{darkgreen}189 & \cellcolor{green}60 & \cellcolor{green}60 & \cellcolor{green}60 \\
	\hline
\begin{lstlisting}
primary_fuel IN
  ('Solar', 'Biomass', 'Coal')
\end{lstlisting}
& \cellcolor{darkgreen}225 & \cellcolor{green}156 & \cellcolor{green}156 & \cellcolor{green}156 \\
	\hline
\begin{lstlisting}
AND source = 'Wiki-Solar'
\end{lstlisting}
& \cellcolor{red}24 & \cellcolor{green}46 & \cellcolor{green}42 & \cellcolor{green}40 \\
	\hline
\begin{lstlisting}
AND longitude > 40.
AND longitude < 70.
\end{lstlisting}
& \cellcolor{red}1 & \cellcolor{red}1 & \cellcolor{green}35 & \cellcolor{green}33 \\
	\hline
\end{tabular}
\footnotetext{
\includegraphics[scale=0.4]{pics/GPPD-copyright}
}
\end{center}
\end{frame}

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Final frame
%
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}
\begin{center}
\begin{center}
\includegraphics[scale=0.1]{pics/project_logo}
\end{center}
\huge{Questions ?}
\end{center}
\vspace{10pt}
\begin{center}
\begin{tabular}{rl}
\makecell[c]{\includegraphics[scale=0.1]{pics/extensionlink}} & \tbltext{\makecell[l]{The pg\_index\_stats extension\\ github link}} \\
\makecell[c]{\includegraphics[scale=0.1]{pics/pgpro}} & \tbltext{\makecell[l]{Postgres Professional LLC\\ The Russian Postgres Company}} \\
\end{tabular}
\end{center}
\end{frame}

\end{document}
