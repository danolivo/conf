\documentclass{article}
\usepackage[russian]{babel} % REMOVE before submission !!!
\usepackage{graphicx}
\usepackage{url}

\begin{document}
\title{Introducing re-optimisation in PostgreSQL}
\author{Andrei Lepikhov, Alena Rybakina}
\date{May 2024}

\maketitle

\begin{abstract}
Years of PostgreSQL optimiser enhancement have added many new features and raised hard questions, especially about restraining an estimation error and the best plan selection. Maintenance purposes need to create tools that can correct inaccurate planning decisions. In this paper, we explain in detail a re-optimisation technique implemented in PostgreSQL to detect and re-optimise queries, being fully transparent either to a client or an application. We also show some issues that haven't been covered in theoretical research before. Using the Join-Order Benchmark, we demonstrate the efficacy of the approach.
\end{abstract}


\section{Introduction}
\parСуществует множество причин, которые приводят к чрезмерно длительному выполнению запроса: это может быть неправильный порядок выполнения операций соединения, неоптимальный выбор алгоритма для операции, лимиты по памяти, приводящие к спиллингу данных на диск в операциях сортировки и хэширования и др.
\parНа сегодняшний день набирает популярность подход, называемый адаптивным планированием запросов. Его суть заключается в использовании методов машинного обучения для предсказания кардинальности нод плана запроса. Сделав попытку реализации такой методики в коде PostgreSQL мы столкнулись с массой фундаментальных проблем, среди которых присутствует необходимость переобучения после каждой команды DDL, сложность с поддержкой локальных объектов базы данных, таких как временные таблицы, неучет базой знаний области видимости транзакций и возможность переноса трактовки получаемых из плана выполненного запроса на последующие запросы. Источником большинства этих проблем является использование базы знаний вне контекста запроса, на котором эти знания получены и внутри других бэкендов.
\parОбнаружение данных проблем, выявленных в ходе разработки и последующей эксплуатации данного расширения натолкнуло нас на идею ре-оптимизации, которая может быть локализована в рамках одного бэкенда.
\parПовторная оптимизация означает остановку выполнения запроса и запуск его заново. Очевидно, что такая техника имеет мало практического смысла, если ре-оптимизация будет повторяться каждый раз при поступлении одного и того же запроса. Однако при наличии некоторого рода "памяти" опимизатора, когда наиболее оптимальный план будет запоминаться и храниться в кэше СУБД, данная методика выглядит практичной и позволяющей решать множество проблем оптимизации в реальном времени.
\parВвиду того, что метод "запоминания" плана запроса уже был имплементирован нами для СУБД PostgreSQL ранее \cite{srplan} и уже некоторое время находится в промышленной эксплуатации, здесь мы ограничимся рассмотрением только проблемы ре-оптимизации.
\cite{Perron2019HowIL}
\section{Design of the feature}
Generally speaking, any executor, containing re-optimisation feature have to check some break conditions, implement machinery to stop the query execution, subsystem for analysis of partially executed plan state tree which will gather useful statistics, consequent planning and restart execution with the new query plan.
\subsection{Subtransactions}
\parРе-оптимизация реализована на механизме сабтранзакций. Перед началом следующей попытки выполнения перепланированного запроса, СУБД должна высвободить ресурсы, которые были задействованы во время предыдущей попытки. Данные ресурсы включают в себя оперативную память, блокировки на объекты БД, временные файлы и другие объекты, специфичные для конкретной СУБД. Механизм отката сабтранзакции является штатным инструментом выполнения указанной задачи. Сабтранзакции добавляют накладные расходы на выполнение запроса, поэтому в оптимизатор добавлен код, который на основании плана запроса принимает решение о необходимости активации ре-оптимизации. В случае отрицательного решения, сабтранзакции не используются и запрос обрабатывается стандартным образом. В PostgreSQL, к счастью, содержится достаточно много метаданных о структуре запроса, с помощью которых можно принимать обоснованное решение.
\subsection{Checking of re-optimisation conditions}
\parДля запуска ре-опимизации был разработан механизм триггеров перепланирования. Основная сложность данной подсистемы заключается в том, что бэкенд не может быть остановлен в произвольном состоянии выполнения. Его состояние в момент останова должно быть согласовано с механизмом отката сабтранзакции данной СУБД, чтобы обеспечить корректное высвобожение ресурсов и перевод базы данных в состояние до начала выполнения запроса. При этом, точка останова должна обеспечивать достаточно быструю остановку выполнения запроса. В данной реализации проверка условий ре-оптимизации возложена на функцию next итераторной модели~\cite{Graefe1992} PostgreSQL, именуемой \textit{ExecuteNode}. То есть, время реагирования на событие перепланирования не превышает времени формирования тупла нодой плана запроса.
\parДискуссионным данное решение делает то соображение, что при выполнении некоторых операций, например ожидания блокировки, сортировки, реорганизации хэш-таблицы или в состоянии реорганизации дискового кэша операции HashJoin, бэкенд может достаточно долгое время находиться в промежуточном состоянии и не вычитывать данные ни из одной ноды. Однако учитывая основную задачу, решаемую данной фичей, мы считаем данную особенность допустимой.
\subsection{Execution Interruption}
\parВ момент срабатывания триггера СУБД должна корректно остановить выполнение запроса и передать управление модулю ре-оптимизации. Основную сложность здесь представляет сложная иерархия запросов: запрос верхнего уровня может содержать вызовы хранимых процедур, которые сами по себе содержат один и более запросов, в том числе формируемых динамически. Остановка такой сложно организованной иерархии достаточно надёжным способом требует использования штатных средств ядра СУБД. В PostgreSQL имеется только один механизм, позволяющий корректно остановить выполнение запроса - механизм обработки ошибок. Соответственно, в ядро СУБД был добавлен дополнительный тип ошибки - срабатывание триггера перепланирования - и реализован механизм обработки данного типа ошибки, обеспечивающий анализ состояния плана частично выполненного запроса, планирование с учетом информации, полученной на предыдущем этапе и запуск повторного выполнения.
\parЗдесь также имеется пространство для критики. Хранимые процедуры имеют встроенные средства обработки исключений, которые позволяют обрабатывать ошибки произвольной сложности, равно как и игнорировать их. Таким образом, подобная процедура может просто проигнорировать созданное данным инструментом событие перепланирования. Имея возможности отключить перепланирование при обнаружении подобной языковой конструкции, в данной работе мы предпочли принять, что время выполнения критических секций хранимых процедур заведомо ограничено по времени и достаточно предусмотреть срабатывание триггера перепланирования немедленно, после выхода из данной секции.
\section{Planning signature}
Для реализации механизма перепланирования необходимо обеспечить идентификацию ноды плана запроса. Основная сложность данной задачи в СУБД PostgreSQL заключается в том, что оптимизация является многоступенчатым процессом, в котором дерево запроса проходит через серию преобразований и отсутствует возможность однозначно сопоставить кардинальность ноды плана запроса тем достаточно абстрактным структурам данных, на основе которых выполняется оценка кардинальности.
Ранее мы уже делали попытку использ
В PostgreSQL для оценки кардинальности используется структура RelOptInfo, являющаяся неточной абстракцией понятия реляционной операции. Для оценки кардинальности используется тип операции (например, OUTER JOIN), набор выражений, применяемых в качестве условий операции и фильтров данных, набор таблиц, из которых извлекаются данные в поддереве, поступающем на каждый из входов данной операции.
\section{Hidden nuances}
\subsection{Breaking criteria}
Подзапросы
множественные стэйтменты
Снапшот
Что использовать для перепланирования
\bibliographystyle{plain}
\bibliography{references}
\end{document}
