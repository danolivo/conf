\documentclass{article}
\usepackage{graphicx}
\usepackage{url}
\usepackage[russian]{babel} % REMOVE before submission !!!

\begin{document}
\title{Introducing re-optimisation in PostgreSQL}
\author{Andrei Lepikhov, Alena Rybakina}
\date{May 2024}

\maketitle

\begin{abstract}
Years of PostgreSQL optimiser enhancement have added many new features and raised hard questions, especially about restraining an estimation error and the best plan selection. Maintenance purposes need to create tools that can correct inaccurate planning decisions. In this paper, we explain in detail a re-optimisation technique implemented in PostgreSQL to detect and re-optimise queries, being fully transparent either to a client or an application. We also show some issues that haven't been covered in theoretical research before. Using the Join-Order Benchmark, we demonstrate the efficacy of the approach.
\end{abstract}


\section{Introduction}
\parСуществует множество причин, которые приводят к чрезмерно длительному выполнению запроса: это может быть неправильный порядок выполнения операций соединения, неоптимальный выбор алгоритма для операции, лимиты по памяти, приводящие к спиллингу данных на диск в операциях сортировки и хэширования и др.
\parНа сегодняшний день набирает популярность подход, называемый адаптивным планированием запросов. Его суть заключается в использовании методов машинного обучения для предсказания кардинальности нод плана запроса. Сделав попытку реализации такой методики в коде PostgreSQL мы столкнулись с массой фундаментальных проблем, среди которых присутствует необходимость переобучения после каждой команды DDL, сложность с поддержкой локальных объектов базы данных, таких как временные таблицы, неучет базой знаний области видимости транзакций и возможность переноса трактовки получаемых из плана выполненного запроса на последующие запросы. Источником большинства этих проблем является использование базы знаний вне контекста запроса, на котором эти знания получены и внутри других бэкендов.
\parОбнаружение данных проблем, выявленных в ходе разработки и последующей эксплуатации данного расширения натолкнуло нас на идею ре-оптимизации, которая может быть локализована в рамках одного бэкенда.
\parПовторная оптимизация означает остановку выполнения запроса и запуск его заново. Очевидно, что такая техника имеет мало практического смысла, если ре-оптимизация будет повторяться каждый раз при поступлении одного и того же запроса. Однако при наличии некоторого рода "памяти" опимизатора, когда наиболее оптимальный план будет запоминаться и храниться в кэше СУБД, данная методика выглядит практичной и позволяющей решать множество проблем оптимизации в реальном времени.
\parВвиду того, что метод "запоминания" плана запроса уже был имплементирован нами для СУБД PostgreSQL ранее \cite{srplan} и уже некоторое время находится в промышленной эксплуатации, здесь мы ограничимся рассмотрением только проблемы ре-оптимизации.
\cite{Perron2019HowIL}
\section{Components of the technique}
\subsection{Subtransactions}
\parРе-оптимизация реализована на механизме сабтранзакций. Перед началом выполнения перепланированного ранее запроса, СУБД должна высвободить ресурсы, задействованные ранее для выполнения данного запроса. Данные ресурсы включают в себя оперативную память, блокировки на объекты БД, временные файлы и другие объекты, специфичные для конкретной СУБД. Механизм отката сабтранзакции является штатным инструментом выполнения указанной задачи. Сабтранзакции добавляют накладные расходы на выполнение запроса, поэтому в оптимизатор добавлен модуль, который на основании плана запроса принимает решение о необходимости активации ре-оптимизации. В случае отрицательного решения, сабтранзакции не используются и запрос обрабатывается стандартным образом.
\subsection{Re-optimisation triggers}
\parДля запуска ре-опимизации был разработан механизм триггеров перепланирования. Основная сложность данной подсистемы заключается в том, что бэкенд не может быть остановлен в произвольном состоянии выполнения. Его состояние в момент останова должно быть согласовано с механизмом отката сабтранзакции данной СУБД, чтобы обеспечить корректное высвобожение ресурсов и перевод базы данных в состояние до начала выполнения запроса. При этом, точка останова должна обеспечивать достаточно быструю остановку выполнения запроса. В данной реализации бэкенд выполняет проверку условий триггеров ре-оптимизации непосредственно после выдачи тупла любой нодой плана запроса.
\parДискуссионным данное решение делает то соображение, что бэкенд может достаточно долгое время находиться в состоянии сортировки, реорганизации хэш-таблицы или в состоянии обработки данных на диске и не вычитывать данные ни из одной ноды.
\parМеханизм обработки ошибок. В момент срабатывания триггера СУБД должна остановить выполнение запроса и передать управление модулю ре-оптимизации. Для реализации данной логики в PostgreSQL имеется только один механизм - механизм обработки ошибок. Соответственно, в ядро СУБД был добавлен дополнительный тип ошибки - срабатывание триггера перепланирования - и реализован механизм обработки данного типа ошибки, обеспечивающий анализ состояния плана частично выполненного запроса, планирование с учетом информации, полученной на предыдущем этапе и запуск повторного выполнения.
\subsection{}
\section{Planning signature}
\section{Re-optimisational triggers}
\section{Hidden nuances}
Подзапросы
множественные стэйтменты
Снапшот
Что использовать для перепланирования
\bibliographystyle{plain}
\bibliography{references}
\end{document}
