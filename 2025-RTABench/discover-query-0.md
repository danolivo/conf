**Любопытный факт 1**. Какой бы ни был shared_buffers, мы не можем использовать его весь под кэширование одной таблицы. Всегда будет какая-то часть. В условиях нашей задачи это примерно 2.4 ГБ.

**Как влияют воркеры на время выполнения**. Первое, что бросается в глаза - Parallel Bitmap Scan используется при малом количестве воркеров и Parallel Seq Scan - при большом. Попробуем провести эксперименты с отключением и того и другого:
```
SET enable_seqscan = 'off';
SET enable_bitmapscan = 'off';
```

 | nworkers |   O0 |    O3 |    O3,no_bitmap |   O3,no_seqscan |
 | --- | --------- | --------- | --------- | --------- |
 | 08  | 16187.014 | 8333.891  | 9610.689  | 16247.952 |
 | 07  | 16502.277 | 8554.917  | 9869.021  | 16711.503 |
 | 06  | 17427.810 | 8933.199  | 9819.980  | 17682.138 |
 | 05  | 26830.905 | 19323.710 | 9507.894  | 19335.117 |
 | 04  | 27458.219 | 21663.662 | 10313.080 | 21258.223 |
 | 03  | 29547.009 | 23825.013 | 9964.561  | 23572.604 |
 | 02  | 29703.519 | 22299.750 | 9740.750  | 22254.160 |
 | 01  | 29736.359 | 22363.689 | 12472.119 | 22107.194 |
 | 00  | 38107.065 | 21060.564 | 15184.975 | 20248.490 |
 
  Результаты можно посмотреть:
  - Свободный выбор -
  - Only SeqScan - 
  - Only BitmapScan -

Таким образом, увеличивая меняя количество воркеров не стоит делать далеко идущих выводов: *изменение времени выполнения может быть вызвано не самими воркерами, а изменением плана запроса*.

Видим, что запрос выполняется медленно. Это вполне естественно, поскольку нам приходится пройти по всем строкам и вычислить значение предиката. Обычно, для селективной выборки используются индексы. Давайте введём фазу оптимизации 1, добавим индекс и посмотрим, поможет ли он. Вполне естественно иметь один или несколько индексов по одной высоко селективной колонке, часто участвующей в условии выборки. Здесь такая колонка - event_created:
```
CREATE INDEX idx_1 ON order_events (event_created);
```

Здесь приятно уже то, что объём затрагиваемых данных сильно уменьшился и уже вся выборка помещается в shared_buffers и не нужны обращения к диску.

| nworkers | exec_time |
 | --- | --------- |
 | 16  | 917.974 |
 | 12  | 922.861 |
 | 10  | 917.137 |
 | 09  | 968.825 |
 | 08  | 1046.033 |
 | 07  | 1132.110 |
 | 06  | 1244.223 |
 | 05  | 1370.313 |
 | 04  | 1554.178 |
 | 03  | 1833.563 |
 | 02  | 2425.377 |
 | 01  | 3265.883 |
 | 00  | 6591.995 |

Цифры получаются весьма хорошие. Более того, заметно, что эффект распараллеливания теперь работает сильно лучше и даже 9 процессов имеет смысл использовать.

Давайте пойдем дальше и на фазе 2 посмотрим, какой эффект можно получить от различных индексов. Попробуем разные варианты:

```
CREATE INDEX idx_3 ON order_events (event_created, event_type);
CREATE INDEX idx_2 ON order_events (event_created, event_type) INCLUDE (event_payload);
```

Здесь есть как большой компактный индекс, который требует хождения в таблицу и IndexOnlyScan, который однако будет избыточно большим, поскольку колонка event_payload имеет тип jsonb и может быть весьма широка. Результаты:
- IndexScan using idx_1 - 6555.122
- Index Only Scan using idx_2 - 1586.097
- Bitmap Index Scan on idx_3 - 1286.430

В отсутствие  idx_3, оптимизатор выбирает  IndexScan по idx1 перед IndexOnlyScan по idx_2. Почему так происходит сказать сложно, поскольку EXPLAIN не даёт нам детальной информации, сколько строк предполагалось пофетчить с диска и впостледствии отфильтровать. И сколько блоков предполагалось потрогать, чтобы достать все нужные строки.
Судя по времени сканирования, компактный индекс выглядит более привлекательным, нежели широкий но IndexOnlyScan. Любопытно. Оставим его и попробуем варьировать параллельных воркеров.
Такой индекс уже не выглядит совсем уж естественным, а скорее заточенным под конкретный проблемный запрос или группу запросов. Но мы здесь просто смотрим потенциал оптимизации.

Любопытно также, что на количестве воркеров 9 BitmapScan резко свалился в SeqScan и затормозил.

Отключим BitmapScan с его индексом и посмотрим, как будет параллелиться IndexOnlyScan:

`UPDATE pg_index SET indisvalid=false FROM pg_class WHERE relname = 'idx_3' AND oid=indexrelid;`

IndexOnlyScan распараллелился лучше и не свалился в SeqScan.

Давайте теперь попробуем достичь теоретических пределов оптимизации этого запроса, используя всё, что есть под рукой и не обращая внимания на практичность решения - назовем это фазой 3.

Первое, избавимся от туплов, которые будут отфильтрованы на диске - частичные индексы:

```
CREATE INDEX idx_4 ON order_events (event_created, event_type) INCLUDE (event_payload)
WHERE ((event_payload ->> 'terminal'::text) = ANY ('{Berlin,Hamburg,Munich}'::text[]));
```

Здесь также можно заметить, что потенциальная альтернатива - создать небольшие частичные индексы для каждого города. Однако оптимизатор не умеет разворачивать конструкцию x IN (y,z,w) в серию OR-ов, чтобы затем при помощи операции BitmapOr объединить результаты сканирования нескольких индексов.
Однако, можно попробовать совсем мало реальный кейс и сделать частичный индекс по всему фильтру запроса:

```
CREATE INDEX idx_5 ON order_events (event_created, event_type) INCLUDE (event_payload)
WHERE
  event_created >= '2024-01-01' and event_created < '2024-02-01' AND
  event_type IN ('Created', 'Departed', 'Delivered') AND
  (event_payload ->> 'terminal'::text) = ANY ('{Berlin,Hamburg,Munich}'::text[]);
```

Здесь видна ещё одна проблема: даже если частичный индекс полностью охватывает весь фильтр, то оптимизатор не может корректно предсказать кардинальность выборки просто потому, что выполняет оценку по исходной таблице.