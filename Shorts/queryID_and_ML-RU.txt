Технология Query ID открывает путь применению ML-методов в управлении СУБД?

А кто из вас пытался применять методы машинного обучения для автоматизации тюнинга СУБД?
Мы, подразделение оптимизации в компании Postgres Professional, начиная с 2016 года пробуем делать это регулярно: адаптивный оптимизатор запросов [1], фризер планов [2] и перепланировщик [3] тому хорошие примеры.
Основная проблема использования ML внутри СУБД - классификация запросов. Быстро и с хорошей достоверностью отнести запрос к некоторому классу с заранее заданными свойствами ранее было недоступно. Однако с недавнего времени в PostgreSQL появился параметр Query ID, обладающий двумя замечательными свойствами:
1. Он генерируется по дереву плана запроса
2. Формирование данного 64-битного хэша происходит с минимальными накладными расходами.
3. Код генератора Query ID является автогенерируемым по исходному коду СУБД. 
Пункт 1 гарантирует нам независимость от синтаксических особенностей запроса: разделители, регистр записи и т.д. Также, он позволяет учесть правила перезаписи запросов, которые могут изменяться (например изменение определения VIEW) и менять семантическое наполнение запроса.
Пункт 3 позволяет, используя достаточно не инвазивную процедуру, на этапе подготовки дистрибутива создать один или более генераторов Query ID и использовать их в расширениях для различных целей.
Уже в текущей имплементации Query ID позволяет с большой точностью отделять один запрос от другого, позволяя расширению pg_stat_statements собирать статистику выполнения различных запросов. Однако он также и позволяет нам в расширении sr_plan [2], которое сопоставляет входящему запросу “замороженный” план, избегая повторной процедуры оптимизации сначала находи.ть небольшое множество кандидатов и потом доказывать соответствие плана в кэше входящему запросу методом сопоставления деревьв запроса.
Несложно представить себе дальнейшее расширение области применения этого параметра. Например, можно сделать Query ID устойчивым к перестановке порядка следования источников в условии FROM … или выражений в условии WHERE, сделав его более универсальным. Или исключить из хэша значения констант.
В последнем случае мы получаем отличный классификатор, который позволяет анализировать каждый запрос в отдельности и выбирать паттерны его применения, находить часто меняющиеся константы и константы, значимые для времени выполнения запроса или ошибки оценки кардинальности. Таким образом, это открывает путь для разработки алгоритмов автоматического поиска  обобщающих параметризаций запросов, которые следует оптимизировать и, возможно, закреплять в кэше планы таких запросов. Или запоминать набор планов одного запроса и выдавать один из них, который является наиболее оптимальным в какое-то определённое время года, дня или суток. Имея такой классификатор, возможности для применения методов машинного обучения для управления поведением СУБД кардинально расширяются …
А в вашей СУБД есть такой инструмент?

[1] https://github.com/postgrespro/aqo
[2] https://postgrespro.com/docs/enterprise/15/sr-plan
[3] https://pgconf.ru/en/talk/1589471